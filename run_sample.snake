import re
import pandas
# from pytools.persistent_dict import PersistentDict
# size estimation from kmers as well with jellyfish?
# storage = PersistentDict("qcquickie_storage")
# alternative is to do a quick qc on basepairs followed by a more rigorous assembly

configfile: os.path.join(os.path.dirname(workflow.snakefile), "config/config.yaml")
# requires --config R1_reads={read_location},R2_reads={read_location}
sample = config["Sample"]
R1 = config["R1_reads"],
R2 = config["R2_reads"],

include: "snakefiles/qcquickie.snake"
include: "snakefiles/assembly.snake"
include: "snakefiles/analysis.snake"

# my understanding is all helps specify final output
onsuccess:
    print("Workflow complete")
    output = ["sample_status.txt"]
    with open(output[0], "w") as status:
        status.write("Success")
onerror:
    print("Workflow error")
    output = ["sample_status.txt"]
    with open(output[0], "w") as status:
        status.write("Failure")

rule all:
    input:
        "qcquickie_status.txt"

rule run__snake_qcquickie:
    message:
        "qcquickie"
    input:
        reads = (R1, R2),
        sample = sample
    output:
        "qcquickie_status.txt"
    shell:
        "snakemake -s ~/git.repositories/SerumQC-private/snakefiles/qcquickie.snake --config R1_reads={input.reads[0]} R2_reads={input.reads[1]} Sample={input.sample}"

rule run__snake_assembly:
    message:
        "assembly"
    input:
        reads = (R1, R2),
        sample = sample
    output:
        "assembly_status.txt"
    shell:
        "snakemake -s ~/git.repositories/SerumQC-private/serumqc.snake --config R1_reads={input.reads[0]} R2_reads={input.reads[1]} Sample={input.sample}"

rule run__snake_analysis:
    message:
        "analysis"
    input:
        reads = (R1, R2),
        sample = sample
    output:
        "analysis_status.txt"
    shell:
        "snakemake -s ~/git.repositories/SerumQC-private/serumqc.snake --config R1_reads={input.reads[0]} R2_reads={input.reads[1]} Sample={input.sample}"